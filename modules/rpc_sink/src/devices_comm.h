
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.7.0.0
//   File : devices_comm.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/comm/services.h>
#include "devices_types.h"


namespace microsoft
{
namespace azure
{
namespace devices
{
    class Transport
    {
    public:
        virtual ~Transport() = default;

        virtual void Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) = 0;

        virtual void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) = 0;

        struct Schema;
        class Proxy;

        template <template <typename> class Promise>
        class Using;
    };

    struct Transport::Schema
    {
        static const ::bond::Metadata metadata;

        private: static const ::bond::Metadata s_Create_metadata;
        private: static const ::bond::Metadata s_Destroy_metadata;

        public: struct service
        {
            typedef ::bond::reflection::MethodTemplate<
                Transport,
                ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>,
                ::bond::comm::message< ::microsoft::azure::devices::Handle>,
                &Transport::Create,
                &s_Create_metadata
            > Create;

            typedef ::bond::reflection::MethodTemplate<
                Transport,
                ::bond::comm::payload< ::microsoft::azure::devices::Handle>,
                ::bond::comm::message<void>,
                &Transport::Destroy,
                &s_Destroy_metadata
            > Destroy;
        };

        private: typedef boost::mpl::list<> methods0;
        private: typedef boost::mpl::push_front<methods0, service::Destroy>::type methods1;
        private: typedef boost::mpl::push_front<methods1, service::Create>::type methods2;

        public: typedef methods2::type methods;
        
    };
    

    class Transport::Proxy
        : public Transport
    {
    public:
        template <typename ServiceProxy>
        explicit
        Proxy(const ServiceProxy& proxy,
              const std::string& name = Transport::Schema::metadata.qualified_name)
            : _impl(boost::make_shared<__Impl<ServiceProxy>>(proxy, name))
        {}

        explicit
        Proxy(const boost::shared_ptr<Transport>& service)
            : _impl(service)
        {}

        Proxy() = default;

        void Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
        {
            _impl->Create(input, callback);
        }

        void Create(const ::microsoft::azure::devices::CreateTransportArgs& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback)
        {
            _impl->Create(boost::cref(input), callback);
        }

        void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) override
        {
            _impl->Destroy(input, callback);
        }

        void Destroy(const ::microsoft::azure::devices::Handle& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback)
        {
            _impl->Destroy(boost::cref(input), callback);
        }

        template <template <typename> class Promise>
        class Using;

    protected:
        boost::shared_ptr<Transport> _impl;

        template <typename ServiceProxy>
        class __Impl
            : public Transport
        {
        public:
            __Impl(const ServiceProxy& proxy, const std::string& name)
                : _proxy(proxy),
                  _name(name)
            {}

            virtual ~__Impl() = default;

            void Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input,
                const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::Create::metadata.name, input, callback);
            }

            void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
                const std::function<void (const ::bond::comm::message<void>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::Destroy::metadata.name, input, callback);
            }

        private:
            ServiceProxy _proxy;
            const std::string _name;
        };
    };

    template <template <typename> class Promise>
    class Transport::Using
        : public Transport
    {
    public:
        virtual auto Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future()) = 0;

        virtual auto Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future()) = 0;

        void Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
        {
            when(Create(input), ::bond::comm::Continuation(callback));
        }

        void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) override
        {
            when(Destroy(input), ::bond::comm::Continuation(callback));
        }
    };

    template <template <typename> class Promise>
    class Transport::Proxy::Using
        : public Transport::Proxy
    {
    public:
        template <typename ServiceProxy>
        explicit
        Using(const ServiceProxy& proxy,
              const std::string& name = Transport::Schema::metadata.qualified_name)
            : Transport::Proxy(proxy, name)
        {}

        explicit
        Using(const boost::shared_ptr<Transport>& service)
            : Transport::Proxy(service)
        {}

        Using() = default;

        using Transport::Proxy::Create;

        auto Create(const ::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>();

            _impl->Create(input,
                [=](const ::bond::comm::message< ::microsoft::azure::devices::Handle>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto Create(const ::microsoft::azure::devices::CreateTransportArgs& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future())
        {
            return Create(::bond::comm::payload< ::microsoft::azure::devices::CreateTransportArgs>(boost::cref(input)));
        }
        

        using Transport::Proxy::Destroy;

        auto Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message<void>>>();

            _impl->Destroy(input,
                [=](const ::bond::comm::message<void>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto Destroy(const ::microsoft::azure::devices::Handle& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future())
        {
            return Destroy(::bond::comm::payload< ::microsoft::azure::devices::Handle>(boost::cref(input)));
        }
        
    };
    

    class Client
    {
    public:
        virtual ~Client() = default;

        virtual void CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) = 0;

        virtual void SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) = 0;

        virtual void SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) = 0;

        virtual void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) = 0;

        struct Schema;
        class Proxy;

        template <template <typename> class Promise>
        class Using;
    };

    struct Client::Schema
    {
        static const ::bond::Metadata metadata;

        private: static const ::bond::Metadata s_CreateWithTransport_metadata;
        private: static const ::bond::Metadata s_SendEventAsync_metadata;
        private: static const ::bond::Metadata s_SetMessageCallback_metadata;
        private: static const ::bond::Metadata s_Destroy_metadata;

        public: struct service
        {
            typedef ::bond::reflection::MethodTemplate<
                Client,
                ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>,
                ::bond::comm::message< ::microsoft::azure::devices::Handle>,
                &Client::CreateWithTransport,
                &s_CreateWithTransport_metadata
            > CreateWithTransport;

            typedef ::bond::reflection::MethodTemplate<
                Client,
                ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>,
                ::bond::comm::message< ::microsoft::azure::devices::ClientResult>,
                &Client::SendEventAsync,
                &s_SendEventAsync_metadata
            > SendEventAsync;

            typedef ::bond::reflection::MethodTemplate<
                Client,
                ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>,
                ::bond::comm::message< ::microsoft::azure::devices::ClientResult>,
                &Client::SetMessageCallback,
                &s_SetMessageCallback_metadata
            > SetMessageCallback;

            typedef ::bond::reflection::MethodTemplate<
                Client,
                ::bond::comm::payload< ::microsoft::azure::devices::Handle>,
                ::bond::comm::message<void>,
                &Client::Destroy,
                &s_Destroy_metadata
            > Destroy;
        };

        private: typedef boost::mpl::list<> methods0;
        private: typedef boost::mpl::push_front<methods0, service::Destroy>::type methods1;
        private: typedef boost::mpl::push_front<methods1, service::SetMessageCallback>::type methods2;
        private: typedef boost::mpl::push_front<methods2, service::SendEventAsync>::type methods3;
        private: typedef boost::mpl::push_front<methods3, service::CreateWithTransport>::type methods4;

        public: typedef methods4::type methods;
        
    };
    

    class Client::Proxy
        : public Client
    {
    public:
        template <typename ServiceProxy>
        explicit
        Proxy(const ServiceProxy& proxy,
              const std::string& name = Client::Schema::metadata.qualified_name)
            : _impl(boost::make_shared<__Impl<ServiceProxy>>(proxy, name))
        {}

        explicit
        Proxy(const boost::shared_ptr<Client>& service)
            : _impl(service)
        {}

        Proxy() = default;

        void CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
        {
            _impl->CreateWithTransport(input, callback);
        }

        void CreateWithTransport(const ::microsoft::azure::devices::CreateWithTransportArgs& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback)
        {
            _impl->CreateWithTransport(boost::cref(input), callback);
        }

        void SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
        {
            _impl->SendEventAsync(input, callback);
        }

        void SendEventAsync(const ::microsoft::azure::devices::SendEventArgs& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback)
        {
            _impl->SendEventAsync(boost::cref(input), callback);
        }

        void SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
        {
            _impl->SetMessageCallback(input, callback);
        }

        void SetMessageCallback(const ::microsoft::azure::devices::SetMessageCallbackArgs& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback)
        {
            _impl->SetMessageCallback(boost::cref(input), callback);
        }

        void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) override
        {
            _impl->Destroy(input, callback);
        }

        void Destroy(const ::microsoft::azure::devices::Handle& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback)
        {
            _impl->Destroy(boost::cref(input), callback);
        }

        template <template <typename> class Promise>
        class Using;

    protected:
        boost::shared_ptr<Client> _impl;

        template <typename ServiceProxy>
        class __Impl
            : public Client
        {
        public:
            __Impl(const ServiceProxy& proxy, const std::string& name)
                : _proxy(proxy),
                  _name(name)
            {}

            virtual ~__Impl() = default;

            void CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input,
                const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::CreateWithTransport::metadata.name, input, callback);
            }

            void SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input,
                const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::SendEventAsync::metadata.name, input, callback);
            }

            void SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input,
                const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::SetMessageCallback::metadata.name, input, callback);
            }

            void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
                const std::function<void (const ::bond::comm::message<void>&)>& callback) override
            {
                _proxy.Send(_name, Schema::service::Destroy::metadata.name, input, callback);
            }

        private:
            ServiceProxy _proxy;
            const std::string _name;
        };
    };

    template <template <typename> class Promise>
    class Client::Using
        : public Client
    {
    public:
        virtual auto CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future()) = 0;

        virtual auto SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future()) = 0;

        virtual auto SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future()) = 0;

        virtual auto Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future()) = 0;

        void CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::Handle>&)>& callback) override
        {
            when(CreateWithTransport(input), ::bond::comm::Continuation(callback));
        }

        void SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
        {
            when(SendEventAsync(input), ::bond::comm::Continuation(callback));
        }

        void SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input,
            const std::function<void (const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>&)>& callback) override
        {
            when(SetMessageCallback(input), ::bond::comm::Continuation(callback));
        }

        void Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input,
            const std::function<void (const ::bond::comm::message<void>&)>& callback) override
        {
            when(Destroy(input), ::bond::comm::Continuation(callback));
        }
    };

    template <template <typename> class Promise>
    class Client::Proxy::Using
        : public Client::Proxy
    {
    public:
        template <typename ServiceProxy>
        explicit
        Using(const ServiceProxy& proxy,
              const std::string& name = Client::Schema::metadata.qualified_name)
            : Client::Proxy(proxy, name)
        {}

        explicit
        Using(const boost::shared_ptr<Client>& service)
            : Client::Proxy(service)
        {}

        Using() = default;

        using Client::Proxy::CreateWithTransport;

        auto CreateWithTransport(const ::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>();

            _impl->CreateWithTransport(input,
                [=](const ::bond::comm::message< ::microsoft::azure::devices::Handle>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto CreateWithTransport(const ::microsoft::azure::devices::CreateWithTransportArgs& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::Handle>>>().get_future())
        {
            return CreateWithTransport(::bond::comm::payload< ::microsoft::azure::devices::CreateWithTransportArgs>(boost::cref(input)));
        }
        

        using Client::Proxy::SendEventAsync;

        auto SendEventAsync(const ::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>();

            _impl->SendEventAsync(input,
                [=](const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto SendEventAsync(const ::microsoft::azure::devices::SendEventArgs& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future())
        {
            return SendEventAsync(::bond::comm::payload< ::microsoft::azure::devices::SendEventArgs>(boost::cref(input)));
        }
        

        using Client::Proxy::SetMessageCallback;

        auto SetMessageCallback(const ::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>();

            _impl->SetMessageCallback(input,
                [=](const ::bond::comm::message< ::microsoft::azure::devices::ClientResult>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto SetMessageCallback(const ::microsoft::azure::devices::SetMessageCallbackArgs& input)
            -> decltype(std::declval< Promise< ::bond::comm::message< ::microsoft::azure::devices::ClientResult>>>().get_future())
        {
            return SetMessageCallback(::bond::comm::payload< ::microsoft::azure::devices::SetMessageCallbackArgs>(boost::cref(input)));
        }
        

        using Client::Proxy::Destroy;

        auto Destroy(const ::bond::comm::payload< ::microsoft::azure::devices::Handle>& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future())
        {
            auto promise = boost::make_shared<Promise< ::bond::comm::message<void>>>();

            _impl->Destroy(input,
                [=](const ::bond::comm::message<void>& result) mutable
                {
                    promise->set_value(result);
                });

            return promise->get_future();
        }

        auto Destroy(const ::microsoft::azure::devices::Handle& input)
            -> decltype(std::declval< Promise< ::bond::comm::message<void>>>().get_future())
        {
            return Destroy(::bond::comm::payload< ::microsoft::azure::devices::Handle>(boost::cref(input)));
        }
        
    };
    

} // namespace devices
} // namespace azure
} // namespace microsoft
