
//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : Bond Compiler 0.7.0.0
//   File : devices_types.h
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once

#include <bond/core/bond_version.h>

#if BOND_VERSION < 0x0422
#error This file was generated by a newer version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#if BOND_MIN_CODEGEN_VERSION > 0x0700
#error This file was generated by an older version of Bond compiler
#error and is incompatible with your version Bond library.
#endif

#include <bond/core/config.h>
#include <bond/core/containers.h>



namespace microsoft
{
namespace azure
{
namespace devices
{
    
    struct Handle
    {
        uint64_t value;
        
        Handle()
          : value()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Handle(const Handle& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        Handle(Handle&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        Handle(Handle&& other)
          : value(std::move(other.value))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Handle& operator=(const Handle& other) = default;
#endif

        bool operator==(const Handle& other) const
        {
            return true
                && (value == other.value);
        }

        bool operator!=(const Handle& other) const
        {
            return !(*this == other);
        }

        void swap(Handle& other)
        {
            using std::swap;
            swap(value, other.value);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::Handle& left, ::microsoft::azure::devices::Handle& right)
    {
        left.swap(right);
    }

    
    struct Ptr
    {
        uint64_t value;
        
        Ptr()
          : value()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        Ptr(const Ptr& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        Ptr(Ptr&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        Ptr(Ptr&& other)
          : value(std::move(other.value))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        Ptr& operator=(const Ptr& other) = default;
#endif

        bool operator==(const Ptr& other) const
        {
            return true
                && (value == other.value);
        }

        bool operator!=(const Ptr& other) const
        {
            return !(*this == other);
        }

        void swap(Ptr& other)
        {
            using std::swap;
            swap(value, other.value);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::Ptr& left, ::microsoft::azure::devices::Ptr& right)
    {
        left.swap(right);
    }

    
    namespace _bond_enumerators
    {
    namespace TransportProvider
    {
        enum TransportProvider
        {
            Http,
            Mqtt,
            Amqp
        };
        
        extern const std::map<enum TransportProvider, std::string> _value_to_name_TransportProvider;
        extern const std::map<std::string, enum TransportProvider> _name_to_value_TransportProvider;

        inline
        const char* GetTypeName(enum TransportProvider)
        {
            return "TransportProvider";
        }

        inline
        const char* GetTypeName(enum TransportProvider, const ::bond::qualified_name_tag&)
        {
            return "microsoft.azure.devices.TransportProvider";
        }

        inline
        const std::map<enum TransportProvider, std::string>& GetValueToNameMap(enum TransportProvider)
        {
            return _value_to_name_TransportProvider;
        }

        inline
        const std::map<std::string, enum TransportProvider>& GetNameToValueMap(enum TransportProvider)
        {
            return _name_to_value_TransportProvider;
        }

        const std::string& ToString(enum TransportProvider value);

        void FromString(const std::string& name, enum TransportProvider& value);

        inline
        bool ToEnum(enum TransportProvider& value, const std::string& name)
        {
            std::map<std::string, enum TransportProvider>::const_iterator it =
                _name_to_value_TransportProvider.find(name);

            if (_name_to_value_TransportProvider.end() == it)
                return false;

            value = it->second;

            return true;
        }

        inline
        bool FromEnum(std::string& name, enum TransportProvider value)
        {
            std::map<enum TransportProvider, std::string>::const_iterator it =
                _value_to_name_TransportProvider.find(value);

            if (_value_to_name_TransportProvider.end() == it)
                return false;

            name = it->second;

            return true;
        }
    } // namespace TransportProvider
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::TransportProvider;
    

    
    struct CreateTransportArgs
    {
        ::microsoft::azure::devices::TransportProvider provider;
        std::string iotHubName;
        std::string iotHubSuffix;
        
        CreateTransportArgs()
          : provider(::microsoft::azure::devices::_bond_enumerators::TransportProvider::Amqp)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        CreateTransportArgs(const CreateTransportArgs& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        CreateTransportArgs(CreateTransportArgs&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        CreateTransportArgs(CreateTransportArgs&& other)
          : provider(std::move(other.provider)),
            iotHubName(std::move(other.iotHubName)),
            iotHubSuffix(std::move(other.iotHubSuffix))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        CreateTransportArgs& operator=(const CreateTransportArgs& other) = default;
#endif

        bool operator==(const CreateTransportArgs& other) const
        {
            return true
                && (provider == other.provider)
                && (iotHubName == other.iotHubName)
                && (iotHubSuffix == other.iotHubSuffix);
        }

        bool operator!=(const CreateTransportArgs& other) const
        {
            return !(*this == other);
        }

        void swap(CreateTransportArgs& other)
        {
            using std::swap;
            swap(provider, other.provider);
            swap(iotHubName, other.iotHubName);
            swap(iotHubSuffix, other.iotHubSuffix);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::CreateTransportArgs& left, ::microsoft::azure::devices::CreateTransportArgs& right)
    {
        left.swap(right);
    }

    
    namespace _bond_enumerators
    {
    namespace ClientResultValue
    {
        enum ClientResultValue
        {
            Ok,
            InvalidArg,
            Error,
            InvalidSize,
            IndefiniteTime
        };
        
        extern const std::map<enum ClientResultValue, std::string> _value_to_name_ClientResultValue;
        extern const std::map<std::string, enum ClientResultValue> _name_to_value_ClientResultValue;

        inline
        const char* GetTypeName(enum ClientResultValue)
        {
            return "ClientResultValue";
        }

        inline
        const char* GetTypeName(enum ClientResultValue, const ::bond::qualified_name_tag&)
        {
            return "microsoft.azure.devices.ClientResultValue";
        }

        inline
        const std::map<enum ClientResultValue, std::string>& GetValueToNameMap(enum ClientResultValue)
        {
            return _value_to_name_ClientResultValue;
        }

        inline
        const std::map<std::string, enum ClientResultValue>& GetNameToValueMap(enum ClientResultValue)
        {
            return _name_to_value_ClientResultValue;
        }

        const std::string& ToString(enum ClientResultValue value);

        void FromString(const std::string& name, enum ClientResultValue& value);

        inline
        bool ToEnum(enum ClientResultValue& value, const std::string& name)
        {
            std::map<std::string, enum ClientResultValue>::const_iterator it =
                _name_to_value_ClientResultValue.find(name);

            if (_name_to_value_ClientResultValue.end() == it)
                return false;

            value = it->second;

            return true;
        }

        inline
        bool FromEnum(std::string& name, enum ClientResultValue value)
        {
            std::map<enum ClientResultValue, std::string>::const_iterator it =
                _value_to_name_ClientResultValue.find(value);

            if (_value_to_name_ClientResultValue.end() == it)
                return false;

            name = it->second;

            return true;
        }
    } // namespace ClientResultValue
    } // namespace _bond_enumerators

    using namespace _bond_enumerators::ClientResultValue;
    

    
    struct ClientResult
    {
        ::microsoft::azure::devices::ClientResultValue value;
        
        ClientResult()
          : value(::microsoft::azure::devices::_bond_enumerators::ClientResultValue::Ok)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        ClientResult(const ClientResult& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        ClientResult(ClientResult&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        ClientResult(ClientResult&& other)
          : value(std::move(other.value))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        ClientResult& operator=(const ClientResult& other) = default;
#endif

        bool operator==(const ClientResult& other) const
        {
            return true
                && (value == other.value);
        }

        bool operator!=(const ClientResult& other) const
        {
            return !(*this == other);
        }

        void swap(ClientResult& other)
        {
            using std::swap;
            swap(value, other.value);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::ClientResult& left, ::microsoft::azure::devices::ClientResult& right)
    {
        left.swap(right);
    }

    
    struct ClientConfig
    {
        ::microsoft::azure::devices::TransportProvider transport;
        std::string deviceId;
        std::string deviceKey;
        std::string deviceSasToken;
        std::string iotHubName;
        std::string iotHubSuffix;
        std::string protocolGatewayHostName;
        
        ClientConfig()
          : transport(::microsoft::azure::devices::_bond_enumerators::TransportProvider::Amqp)
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        ClientConfig(const ClientConfig& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        ClientConfig(ClientConfig&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        ClientConfig(ClientConfig&& other)
          : transport(std::move(other.transport)),
            deviceId(std::move(other.deviceId)),
            deviceKey(std::move(other.deviceKey)),
            deviceSasToken(std::move(other.deviceSasToken)),
            iotHubName(std::move(other.iotHubName)),
            iotHubSuffix(std::move(other.iotHubSuffix)),
            protocolGatewayHostName(std::move(other.protocolGatewayHostName))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        ClientConfig& operator=(const ClientConfig& other) = default;
#endif

        bool operator==(const ClientConfig& other) const
        {
            return true
                && (transport == other.transport)
                && (deviceId == other.deviceId)
                && (deviceKey == other.deviceKey)
                && (deviceSasToken == other.deviceSasToken)
                && (iotHubName == other.iotHubName)
                && (iotHubSuffix == other.iotHubSuffix)
                && (protocolGatewayHostName == other.protocolGatewayHostName);
        }

        bool operator!=(const ClientConfig& other) const
        {
            return !(*this == other);
        }

        void swap(ClientConfig& other)
        {
            using std::swap;
            swap(transport, other.transport);
            swap(deviceId, other.deviceId);
            swap(deviceKey, other.deviceKey);
            swap(deviceSasToken, other.deviceSasToken);
            swap(iotHubName, other.iotHubName);
            swap(iotHubSuffix, other.iotHubSuffix);
            swap(protocolGatewayHostName, other.protocolGatewayHostName);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::ClientConfig& left, ::microsoft::azure::devices::ClientConfig& right)
    {
        left.swap(right);
    }

    
    struct CreateWithTransportArgs
    {
        ::microsoft::azure::devices::Handle transport;
        ::microsoft::azure::devices::ClientConfig config;
        
        CreateWithTransportArgs()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        CreateWithTransportArgs(const CreateWithTransportArgs& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        CreateWithTransportArgs(CreateWithTransportArgs&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        CreateWithTransportArgs(CreateWithTransportArgs&& other)
          : transport(std::move(other.transport)),
            config(std::move(other.config))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        CreateWithTransportArgs& operator=(const CreateWithTransportArgs& other) = default;
#endif

        bool operator==(const CreateWithTransportArgs& other) const
        {
            return true
                && (transport == other.transport)
                && (config == other.config);
        }

        bool operator!=(const CreateWithTransportArgs& other) const
        {
            return !(*this == other);
        }

        void swap(CreateWithTransportArgs& other)
        {
            using std::swap;
            swap(transport, other.transport);
            swap(config, other.config);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::CreateWithTransportArgs& left, ::microsoft::azure::devices::CreateWithTransportArgs& right)
    {
        left.swap(right);
    }

    
    struct SendEventArgs
    {
        ::microsoft::azure::devices::Handle client;
        ::microsoft::azure::devices::Handle event;
        ::microsoft::azure::devices::Ptr callback;
        ::microsoft::azure::devices::Ptr context;
        
        SendEventArgs()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        SendEventArgs(const SendEventArgs& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        SendEventArgs(SendEventArgs&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        SendEventArgs(SendEventArgs&& other)
          : client(std::move(other.client)),
            event(std::move(other.event)),
            callback(std::move(other.callback)),
            context(std::move(other.context))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        SendEventArgs& operator=(const SendEventArgs& other) = default;
#endif

        bool operator==(const SendEventArgs& other) const
        {
            return true
                && (client == other.client)
                && (event == other.event)
                && (callback == other.callback)
                && (context == other.context);
        }

        bool operator!=(const SendEventArgs& other) const
        {
            return !(*this == other);
        }

        void swap(SendEventArgs& other)
        {
            using std::swap;
            swap(client, other.client);
            swap(event, other.event);
            swap(callback, other.callback);
            swap(context, other.context);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::SendEventArgs& left, ::microsoft::azure::devices::SendEventArgs& right)
    {
        left.swap(right);
    }

    
    struct SetMessageCallbackArgs
    {
        ::microsoft::azure::devices::Handle client;
        ::microsoft::azure::devices::Ptr callback;
        ::microsoft::azure::devices::Ptr context;
        
        SetMessageCallbackArgs()
        {
        }

        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated copy ctor OK
        SetMessageCallbackArgs(const SetMessageCallbackArgs& other) = default;
#endif
        
#if !defined(BOND_NO_CXX11_DEFAULTED_MOVE_CTOR)
        SetMessageCallbackArgs(SetMessageCallbackArgs&& other) = default;
#elif !defined(BOND_NO_CXX11_RVALUE_REFERENCES)
        SetMessageCallbackArgs(SetMessageCallbackArgs&& other)
          : client(std::move(other.client)),
            callback(std::move(other.callback)),
            context(std::move(other.context))
        {
        }
#endif
        
        
#ifndef BOND_NO_CXX11_DEFAULTED_FUNCTIONS
        // Compiler generated operator= OK
        SetMessageCallbackArgs& operator=(const SetMessageCallbackArgs& other) = default;
#endif

        bool operator==(const SetMessageCallbackArgs& other) const
        {
            return true
                && (client == other.client)
                && (callback == other.callback)
                && (context == other.context);
        }

        bool operator!=(const SetMessageCallbackArgs& other) const
        {
            return !(*this == other);
        }

        void swap(SetMessageCallbackArgs& other)
        {
            using std::swap;
            swap(client, other.client);
            swap(callback, other.callback);
            swap(context, other.context);
        }

        struct Schema;

    protected:
        void InitMetadata(const char*, const char*)
        {
        }
    };

    inline void swap(::microsoft::azure::devices::SetMessageCallbackArgs& left, ::microsoft::azure::devices::SetMessageCallbackArgs& right)
    {
        left.swap(right);
    }
} // namespace devices
} // namespace azure
} // namespace microsoft

